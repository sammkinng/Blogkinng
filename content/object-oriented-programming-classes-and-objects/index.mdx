---
title: "[Python] Object-Oriented Programming << Classes and Objects"
description: "Classes act as blueprints for creating objects, enabling developers to model real-world entities and interactions in their code."
image: "../../public/blogs/c-d-x-PDX_a_82obo-unsplash.jpg"
publishedAt: "2024-2-16"
updatedAt: "2024-2-22"
author: "Blogkinng"
isPublished: true
tags:
- python
- oops
---


In the world of `Python` programming, classes and objects serve as the fundamental building blocks of __object-oriented programming__ (OOP), offering a powerful mechanism for organizing code and modeling real-world entities. Classes define the structure and behavior of objects, while objects represent individual instances of those classes. This article delves into the intricate details of classes and objects in `Python`, exploring their significance and role in software development.

The importance of classes and objects in `Python` programming cannot be overstated. They provide a modular and organized approach to code design, promoting reusability, maintainability, and scalability. By understanding and effectively utilizing classes and objects, we can create sophisticated applications that are easier to manage and extend.

## Classes in Python
A class in `Python` is a blueprint for creating objects. It serves as a template or a prototype that defines the attributes (data) and methods (functions) that will be associated with objects created from that class. In other words, a class defines the structure and behavior of objects.

Here's a breakdown of key points about classes in `Python`:

1. **Blueprint for Objects:** A class defines the structure and behavior that objects of that class will possess. It encapsulates data (attributes) and functionality (methods) into a single unit.

2. **Attributes:** Attributes are variables associated with a class that define the state of objects created from that class. They represent the data or properties that objects can have.

3. **Methods:** Methods are functions defined within a class that define the behavior or actions that objects of that class can perform. They operate on the attributes of the class and allow for interaction with the objects.

4. **Instance Creation:** Objects, also known as instances, are created from classes. Each object instantiated from a class is a unique entity with its own set of attributes and methods.

5. **Syntax:** The syntax for defining a class in `Python` involves using the `class` keyword followed by the class name. Inside the class definition, attributes and methods are declared.

```python
class MyClass:
    def __init__(self, attribute):  # Constructor method
        self.attribute = attribute   # Instance attribute
    
    def method(self):                # Instance method
        print("This is a method.")
```

6. **Instance vs. Class Members:** Attributes and methods can belong to either the class itself (class attributes/methods) or individual instances (instance attributes/methods). Class attributes/methods are shared among all instances of the class, while instance attributes/methods are specific to each object.

In summary, a class in `Python` is a fundamental concept in __object-oriented programming__ that defines the blueprint for creating objects with specific attributes and behaviors. It encapsulates data and functionality, enabling the creation of modular and reusable code.

## Creating Objects

In `Python`, a class is a blueprint for creating objects. It defines the structure and behavior of objects by specifying attributes (variables) and methods (functions) that encapsulate data and functionality within a single entity.

Here's a simple example of a class definition in `Python`:

```python
class MyClass:
    def __init__(self, attribute):
        self.attribute = attribute
    
    def method(self):
        print("This is a method.")
```

In this example:
- `class MyClass:` declares the class named `MyClass`.
- `def __init__(self, attribute):` defines the constructor method (`__init__`) which is called when a new instance of the class is created. It takes `attribute` as a parameter and initializes the `attribute` instance variable with the value passed to it.
- `self.attribute = attribute` initializes the instance variable `attribute` with the value passed to the constructor.
- `def method(self):` defines an instance method named `method` which can be called on instances of the class. It prints a simple message.

To initialize object attributes using the constructor (`__init__` method), you simply define the constructor method within the class and use it to assign initial values to instance variables. When creating an object of the class, you pass the required parameters to the constructor, and they are used to initialize the object attributes.

Here's an example of how to initialize object attributes using the constructor:

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# Creating an object of the Person class and initializing attributes
person1 = Person("John", 30)
person2 = Person("Alice", 25)

# Accessing object attributes
print(person1.name)  # Output: John
print(person1.age)   # Output: 30

print(person2.name)  # Output: Alice
print(person2.age)   # Output: 25
```

In this example, the `Person` class has a constructor that takes two parameters (`name` and `age`). When creating objects of the `Person` class (`person1` and `person2`), we pass values for `name` and `age`, which are then used to initialize the `name` and `age` attributes of each object.

## Instance Attributes and Methods


In `Python`, instance attributes and class attributes are two types of attributes that can be defined within a class. They serve different purposes and behave differently. Here's a comparison between instance attributes and class attributes:

1. **Definition:**
   - Instance attributes: Instance attributes are variables that belong to individual instances (objects) of a class. Each object can have its own set of instance attributes with unique values.
   - Class attributes: Class attributes are variables that belong to the class itself rather than individual instances. They are shared among all instances of the class and have the same value for all objects of the class.

2. **Scope:**
   - Instance attributes: Instance attributes are specific to each object and can vary from one object to another. Changes made to instance attributes of one object do not affect other objects.
   - Class attributes: Class attributes are shared among all instances of the class. They are accessible from any instance of the class and have the same value for all objects.

3. **Initialization:**
   - Instance attributes: Instance attributes are typically initialized within the constructor (`__init__` method) of the class. Each object can have different values for its instance attributes.
   - Class attributes: Class attributes are usually defined outside any method in the class and are shared among all instances. They are initialized at the class level and have the same value for all objects.

4. **Access:**
   - Instance attributes: Instance attributes are accessed using dot notation (`object.attribute`). Each object has its own set of instance attributes.
   - Class attributes: Class attributes are accessed using either the class name or an instance of the class (`ClassName.attribute` or `object.attribute`). Since they are shared among all instances, they can be accessed using any instance or the class itself.

Here's an example illustrating the difference between instance attributes and class attributes:

```python
class MyClass:
    class_attribute = "class attribute"

    def __init__(self, instance_attribute):
        self.instance_attribute = instance_attribute

# Creating objects of the MyClass class
obj1 = MyClass("instance attribute 1")
obj2 = MyClass("instance attribute 2")

# Accessing instance attributes
print(obj1.instance_attribute)  # Output: instance attribute 1
print(obj2.instance_attribute)  # Output: instance attribute 2

# Accessing class attribute
print(obj1.class_attribute)      # Output: class attribute
print(obj2.class_attribute)      # Output: class attribute
```

In this example, `instance_attribute` is an instance attribute, and each object (`obj1` and `obj2`) has its own unique value for this attribute. `class_attribute` is a class attribute, and its value is shared among all instances of the class (`MyClass`).

### Definition and implementation of instance methods.
Instance methods in `Python` are functions defined within a class that operate on instance attributes. They are associated with individual instances (objects) of the class and can access and modify the object's state. Instance methods are commonly used to encapsulate behavior that is specific to instances of the class.

Here's how instance methods are defined and implemented in `Python`:

1. **Definition:**
   - Instance methods are defined within a class using the `def` keyword, just like regular functions.
   - The first parameter of an instance method is always `self`, which refers to the instance itself. It allows the method to access and modify instance attributes.
   - Instance methods can take additional parameters after the `self` parameter, depending on the requirements of the method.

2. **Implementation:**
   - Inside an instance method, `self` is used to access instance attributes and other instance methods.
   - Instance methods can perform any operation on instance attributes, including reading, modifying, or performing calculations.
   - They can also call other instance methods or access class attributes if needed.

Here's an example illustrating the definition and implementation of instance methods:

```python
class Car:
    def __init__(self, brand, model, year):
        self.brand = brand
        self.model = model
        self.year = year
        self.odometer_reading = 0

    def get_full_name(self):
        """Return a formatted full name of the car."""
        return f"{self.year} {self.brand} {self.model}"

    def read_odometer(self):
        """Print the current odometer reading."""
        print(f"This car has {self.odometer_reading} miles on it.")

    def update_odometer(self, mileage):
        """
        Set the odometer reading to the given mileage.
        Reject the change if it attempts to roll the odometer back.
        """
        if mileage >= self.odometer_reading:
            self.odometer_reading = mileage
        else:
            print("You cannot roll back the odometer!")

    def increase_odometer(self, miles):
        """Increase the odometer reading by the given number of miles."""
        if miles >= 0:
            self.odometer_reading += miles
        else:
            print("You cannot decrease the odometer reading!")
```

In this example:
- `Car` is a class representing a car with attributes such as brand, model, year, and odometer_reading.
- `get_full_name()`, `read_odometer()`, `update_odometer()`, and `increase_odometer()` are instance methods defined within the class.
- These instance methods take `self` as the first parameter, allowing them to access and modify instance attributes such as `make`, `model`, `year`, and `odometer_reading`.
- The `get_full_name()` method returns a formatted string containing the full name of the car.
- The `read_odometer()` method prints the current odometer reading.
- The `update_odometer()` method updates the odometer reading to the given mileage, but it rejects changes that attempt to roll the odometer back.
- The `increase_odometer()` method increases the odometer reading by the given number of miles, ensuring that the value is non-negative.

## Class Attributes and Methods

Class attributes and methods in `Python` are features of a class that are shared among all instances (objects) of the class. They are associated with the class itself rather than individual instances, allowing for the definition of properties and behaviors that are consistent across all objects of the class. Here's a detailed explanation of class attributes and methods:

1. **Class Attributes:**
   - Class attributes are variables that are defined within the class but outside any method.
   - They are shared among all instances of the class and have the same value for every object of the class.
   - Class attributes are accessed using either the class name or an instance of the class.
   - They are typically used to define properties or characteristics that are common to all instances of the class.

   ```python
   class MyClass:
       class_attribute = "class attribute"

   # Accessing class attribute using the class name
   print(MyClass.class_attribute)  # Output: class attribute

   # Accessing class attribute using an instance of the class
   obj = MyClass()
   print(obj.class_attribute)  # Output: class attribute
   ```

2. **Class Methods:**
   - Class methods are functions defined within the class that operate on class-level data.
   - They are decorated with the `@classmethod` decorator to indicate that they are class methods.
   - Class methods take a special parameter conventionally named `cls`, which refers to the class itself.
   - They can access and modify class attributes but not instance attributes.
   - Class methods are often used to define utility functions or operations that are related to the class as a whole.

   ```python
   class MyClass:
       class_attribute = "class attribute"

       @classmethod
       def class_method(cls):
           print(cls.class_attribute)

   # Calling class method using the class name
   MyClass.class_method()  # Output: class attribute

   # Calling class method using an instance of the class
   obj = MyClass()
   obj.class_method()  # Output: class attribute
   ```

Class attributes and methods provide a way to define properties and behaviors that are shared among all instances of a class. They contribute to the overall structure and functionality of the class, enabling code organization and promoting reusability. By understanding and utilizing class attributes and methods, we can design more robust and scalable object-oriented solutions in `Python`.

## Encapsulation

Encapsulation and data hiding are fundamental concepts in __object-oriented programming__ (OOP) that promote the organization, modularity, and security of code by controlling access to data within objects. Let's explore each concept in detail:

1. **Encapsulation:**
   
   Encapsulation refers to the bundling of data (attributes) and methods (functions) that operate on that data within a single unit, typically a class. It allows for the abstraction of implementation details and the creation of well-defined boundaries between different components of a program.

   Key aspects of encapsulation include:

   - **Data Abstraction:** Encapsulation hides the internal implementation details of objects, exposing only relevant information through well-defined interfaces. This abstraction allows users of the class to interact with objects without needing to understand the intricacies of their internal workings.
   
   - **Data Hiding:** Encapsulation also involves restricting direct access to the internal state of objects, preventing external code from modifying the object's data without going through designated methods. This helps maintain the integrity of the object's state and ensures that it remains consistent and valid.

   - **Modularity:** By encapsulating related data and behavior within a class, encapsulation promotes modularity and code organization. Each class serves as a self-contained unit with its own set of attributes and methods, facilitating easier maintenance, reuse, and extension of code.

   - **Information Hiding:** Encapsulation hides the implementation details of a class, revealing only the essential information needed for interacting with objects. This shields users of the class from unnecessary complexity and reduces the risk of unintended side effects caused by direct manipulation of internal state.

2. **Data Hiding:**
   
   Data hiding is a specific aspect of encapsulation that focuses on controlling access to the internal state of objects. It involves restricting direct access to object attributes and providing controlled mechanisms (such as getter and setter methods) for accessing and modifying those attributes.

   Key points about data hiding:

   - **Private Attributes:** In languages like `Python`, data hiding is often implemented using access specifiers, such as private, protected, and public. Private attributes are accessible only within the class where they are defined, preventing external code from directly accessing or modifying them.

   - **Getter and Setter Methods:** To interact with private attributes, classes typically provide getter methods for accessing the attribute's value and setter methods for modifying it. These methods encapsulate the logic for accessing and modifying the attribute, allowing the class to enforce constraints or perform additional operations as needed.

   - **Encapsulation of State:** By encapsulating the internal state of objects and exposing it through controlled interfaces, data hiding ensures that the object's state remains encapsulated and protected from unauthorized access or modification. This enhances the reliability and robustness of the code by preventing unintended changes to object state.


### Access specifiers in Python: public, private, and protected

In `Python`, encapsulation and data hiding are achieved using access specifiers, which control the visibility and accessibility of class members (attributes and methods). `Python` provides three levels of access specifiers:

1. **Public Access Specifier**: 
   - Attributes and methods that are not prefixed with an underscore (_) are considered public and can be accessed from outside the class.
   - Public members are accessible by any code that can access the object.

Example:
```python
class MyClass:
    def __init__(self):
        self.public_attribute = 10

    def public_method(self):
        return "This is a public method."

obj = MyClass()
print(obj.public_attribute)  # Output: 10
print(obj.public_method())   # Output: This is a public method.
```

2. **Private Access Specifier**:
   - Attributes and methods that are prefixed with double underscores (__) are considered private and cannot be accessed directly from outside the class.
   - Private members are accessible only within the class itself, and not from outside.

Example:
```python
class MyClass:
    def __init__(self):
        self.__private_attribute = 20

    def __private_method(self):
        return "This is a private method."

obj = MyClass()
# Attempting to access private members will result in an AttributeError
# print(obj.__private_attribute)  # AttributeError: 'MyClass' object has no attribute '__private_attribute'
# print(obj.__private_method())   # AttributeError: 'MyClass' object has no attribute '__private_method'
```

3. **Protected Access Specifier**:
   - In `Python`, there is no strict enforcement of protected access like some other languages. Conventionally, attributes and methods prefixed with a single underscore (_) are considered protected, indicating that they are intended for internal use or for use by subclasses.
   - Protected members can be accessed from within the class itself and its subclasses, but not from outside.

Example:
```python
class MyClass:
    def __init__(self):
        self._protected_attribute = 30

    def _protected_method(self):
        return "This is a protected method."

class SubClass(MyClass):
    def __init__(self):
        super().__init__()

    def access_protected(self):
        return self._protected_attribute

obj = SubClass()
print(obj.access_protected())     # Output: 30
print(obj._protected_method())     # Output: This is a protected method.
```

### Best practices for encapsulating data within classes
Encapsulating data within classes is a fundamental principle of __object-oriented programming__ (OOP) that promotes modularity, data hiding, and abstraction. By encapsulating data, you can protect it from unauthorized access and manipulation, improving code maintainability and reducing the risk of unintended side effects. Here are some best practices for encapsulating data within classes:

1. **Use Access Specifiers**: 
   - Utilize access specifiers such as public, private, and protected to control the visibility of class members.
   - Mark attributes and methods as private (`__`) if they are intended for internal use only, and use public methods to provide controlled access to private data.

2. **Follow the Principle of Least Privilege**:
   - Limit the visibility of class members to only what is necessary for external code to interact with the class.
   - Expose a minimal and well-defined interface to external code, hiding unnecessary implementation details.

3. **Provide Getter and Setter Methods**:
   - Instead of directly accessing or modifying attributes, provide getter and setter methods to encapsulate access to the data.
   - Getter methods allow read-only access to attributes, while setter methods validate and control the modification of attribute values.

4. **Implement Property Decorators**:
   - Use property decorators (`@property`, `@attribute.setter`, `@attribute.deleter`) to define computed properties or to customize attribute access and modification behavior.
   - Property decorators allow you to define getter, setter, and deleter methods in a more concise and Pythonic way.

5. **Avoid Direct Attribute Access from Outside the Class**:
   - Encourage external code to interact with class data through methods rather than directly accessing attributes.
   - This prevents external code from bypassing encapsulation and ensures that data access is controlled and validated.

6. **Document Encapsulation Choices**:
   - Clearly document the encapsulation choices made for each class, including the rationale behind access specifiers, the purpose of getter and setter methods, and any constraints or conventions regarding data access and modification.

7. **Consider Immutability**:
   - Make class attributes immutable (if appropriate) to prevent unintended modifications.
   - Immutable objects are safer to share between multiple objects or threads, as they cannot be changed after creation.

8. **Use Composition and Aggregation**:
   - Instead of exposing internal attributes directly, use composition and aggregation to encapsulate related objects and expose higher-level interfaces.
   - Encapsulating complex behavior in separate objects promotes code reuse, modularity, and maintainability.

9. **Test Encapsulation Boundaries**:
   - Write unit tests to verify that encapsulation boundaries are properly enforced and that class behavior remains consistent when interacting with external code.

10. **Follow Naming Conventions**:
    - Use meaningful and descriptive names for attributes, methods, and classes to convey their purpose and usage.
    - Use prefixes such as `_` for protected members and `__` for private members to indicate their visibility.

By following these best practices, you can effectively encapsulate data within classes, making your code more robust, maintainable, and secure. Encapsulation promotes information hiding, abstraction, and separation of concerns, leading to cleaner and more organized codebases.
## Special Methods (Magic Methods)

Special methods, also known as magic methods, imbue classes with custom behaviors, responding to specific operations or built-in functions. They are identified by double underscores (`__`) before and after the method name.

### Commonly used special methods and their purposes (__str__, __repr__, __add__, etc.)
Special methods, also known as magic methods or dunder methods (due to their double underscore prefix), are built-in methods in `Python` that provide syntactic sugar and enable customization of object behavior. These methods are invoked by specific syntax or built-in functions and allow objects to emulate built-in types or respond to various operations.

Here's an overview of some commonly used special methods in `Python`:

1. **`__init__(self, ...)`:**
   - Constructor method called when an object is initialized. It initializes object attributes and performs any setup required during object creation.

2. **`__str__(self)`, `__repr__(self)`:**
   - `__str__` method returns a string representation of an object, intended for end-users.
   - `__repr__` method returns an unambiguous string representation of an object, typically used for debugging and logging.
   - If `__str__` is not defined, `__repr__` is used as a fallback.

3. **`__len__(self)`:**
   - Returns the length of an object. Invoked by the built-in `len()` function.

4. **`__getitem__(self, key)`, `__setitem__(self, key, value)`, `__delitem__(self, key)`:**
   - `__getitem__` method allows objects to support indexing and slicing operations.
   - `__setitem__` method allows objects to support item assignment.
   - `__delitem__` method allows objects to support item deletion.
   - These methods are invoked when using indexing (`obj[key]`), slicing (`obj[start:stop:step]`), assignment (`obj[key] = value`), or deletion (`del obj[key]`) operations.

5. **`__iter__(self)`, `__next__(self)`:**
   - `__iter__` method returns an iterator object. Invoked when an object is iterated over using a loop or comprehension.
   - `__next__` method returns the next item in the iteration sequence. Invoked by the `next()` function.

6. **`__contains__(self, item)`:**
   - Checks if an item is present in an object. Invoked by the `in` operator.

7. **`__eq__(self, other)`, `__ne__(self, other)`, `__lt__(self, other)`, `__le__(self, other)`, `__gt__(self, other)`, `__ge__(self, other)`:**
   - Comparison methods used to implement object comparison and sorting.
   - Invoked by comparison operators (`==`, `!=`, `<`, `<=`, `>`, `>=`).

8. **`__add__(self, other)`, `__sub__(self, other)`, `__mul__(self, other)`, `__truediv__(self, other)`, `__floordiv__(self, other)`, `__mod__(self, other)`:**
   - Arithmetic methods used to implement object arithmetic operations.
   - Invoked by arithmetic operators (`+`, `-`, `*`, `/`, `//`, `%`).

9. **`__call__(self, ...)`:**
   - Enables objects to be called as functions. Invoked when using parentheses (`obj()`).

10. **`__enter__(self)`, `__exit__(self, exc_type, exc_value, traceback)`:**
    - Special methods used to implement context management protocol for objects used in `with` statements.

These special methods allow objects to customize their behavior and integrate seamlessly with Python's built-in functions, operators, and syntax, making them powerful tools for __object-oriented programming__ and abstraction. By defining these methods appropriately, you can make your objects behave like built-in types or support various operations and protocols in a Pythonic way.

### Examples illustrating the usage of special methods:

Here are examples illustrating the usage of some commonly used special methods in `Python`:

1. **`__init__(self, ...)`: Constructor Method**
   - Initializes object attributes during object creation.

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

# Creating an instance of the Point class
point = Point(3, 4)
print(point.x, point.y)  # Output: 3 4
```

2. **`__str__(self)` and `__repr__(self)`: String Representation**
   - `__str__` returns a string representation of the object, intended for end-users.
   - `__repr__` returns an unambiguous string representation, typically used for debugging.

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __str__(self):
        return f"Point({self.x}, {self.y})"

    def __repr__(self):
        return f"Point(x={self.x}, y={self.y})"

# Creating an instance of the Point class
point = Point(3, 4)
print(str(point))   # Output: Point(3, 4)
print(repr(point))  # Output: Point(x=3, y=4)
```

3. **`__add__(self, other)`: Addition Operator**
   - Defines behavior for the addition operator (`+`).

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Point(self.x + other.x, self.y + other.y)

# Creating instances of the Point class
point1 = Point(3, 4)
point2 = Point(5, 6)
result = point1 + point2
print(result.x, result.y)  # Output: 8 10
```

4. **`__len__(self)`: Length Method**
   - Returns the length of the object.

```python
class MyList:
    def __init__(self, items):
        self.items = items

    def __len__(self):
        return len(self.items)

# Creating an instance of the MyList class
my_list = MyList([1, 2, 3, 4, 5])
print(len(my_list))  # Output: 5
```

5. **`__getitem__(self, key)`: Indexing and Slicing**
   - Defines behavior for accessing items using indexing and slicing.

```python
class MyList:
    def __init__(self, items):
        self.items = items

    def __getitem__(self, key):
        return self.items[key]

# Creating an instance of the MyList class
my_list = MyList([1, 2, 3, 4, 5])
print(my_list[0])    # Output: 1
print(my_list[1:3])  # Output: [2, 3]
```

These examples demonstrate how special methods can be used to customize object behavior, making objects behave like built-in types or supporting various operations and protocols in `Python`. By implementing these methods, you can provide a more intuitive and seamless experience when working with custom objects in your `Python` code.

## Conclusion
In conclusion, classes and objects play a crucial role in `Python` programming, serving as the fundamental building blocks of __object-oriented programming__ (OOP). They provide a powerful mechanism for organizing code, modeling real-world entities, and promoting reusability, maintainability, and scalability. Throughout this article, we have explored various aspects of classes and objects in `Python`, highlighting their significance and role in software development.

**Key Points:**
- **Classes in Python:** Classes define the structure and behavior of objects, encapsulating data (attributes) and functionality (methods) into a single unit. They serve as blueprints for creating objects with specific attributes and behaviors.
- **Object Creation:** Objects, also known as instances, are created from classes and represent individual entities with their own set of attributes and methods.
- **Initialization and Instance Methods:** Constructors (`__init__` method) are used to initialize object attributes, while instance methods define behavior specific to instances of the class.
- **Instance vs. Class Attributes/Methods:** Instance attributes/methods are specific to each object, while class attributes/methods are shared among all instances.
- **Encapsulation and Data Hiding:** Encapsulation bundles data and methods within a class, promoting modularity, abstraction, and information hiding. Access specifiers control visibility and accessibility of class members.
- **Special Methods:** Special methods, also known as magic methods, enable customization of object behavior in response to specific operations or built-in functions.

By understanding and effectively utilizing classes and objects in `Python`, we can create modular, organized, and maintainable codebases. Encapsulation and data hiding ensure the integrity and security of class data, while special methods provide flexibility and customization options for object behavior. With these concepts and practices, `Python` programmers can build sophisticated applications that are easier to manage, extend, and maintain.

---
### References

1. Python Documentation: Classes - https://docs.python.org/3/tutorial/classes.html
2. Real Python: Python Class Attributes: An Overly Thorough Guide - https://realpython.com/instance-class-and-static-methods-demystified/
3. GeeksforGeeks: Python Object Oriented Programming - https://www.geeksforgeeks.org/python-object-oriented-programming/
4. Programiz: Python Classes and Objects - https://www.programiz.com/python-programming/class
5. Python Docs: Special method names - https://docs.python.org/3/reference/datamodel.html#special-method-names